<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title></title>
</head>
<body>
<script>
// 浏览器渲染过程如下：
//   1.解析HTML，生成DOM树，解析CSS，生成CSSOM树
//   2.将DOM树和CSSOM树结合，生成渲染树(Render Tree)
//   3.Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
//   4.Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素
//   5.Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层）

// 为了构建渲染树，浏览器主要完成了以下工作：
//  从DOM树的根节点开始遍历每个可见节点。
//  对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。
//  根据每个可见节点以及其对应的样式，组合生成渲染树。
//  第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：
//  一些不会渲染输出的节点，比如script、meta、link等。
//  一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。

// 注意：渲染树只包含可见的节点。

// 回流
//  前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。
//  为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历

// 重绘
//  最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。
//  既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。

// 何时发生回流重绘
//  我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：
//  添加或删除可见的DOM元素
//  元素的位置发生变化
//  元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
//  内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
//  页面一开始渲染的时候（这肯定避免不了）
//  浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

// 注意：回流一定会触发重绘，而重绘不一定会回流。
// 根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。

// 浏览器的优化机制
// 现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法：
//  offsetTop、offsetLeft、offsetWidth、offsetHeight
//  scrollTop、scrollLeft、scrollWidth、scrollHeight
//  clientTop、clientLeft、clientWidth、clientHeight
//  getComputedStyle()
//  getBoundingClientRect

// 具体可以访问这个网站：
//  https://gist.github.com/paulirish/5d52fb081b3570c81e3a。

// 以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。
//   因此，我们在修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使用它们，最好将值缓存起来。

// 减少回流与重绘
//  1.直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器）
//  2.让要操作的元素进行”离线处理”，处理完后一起更新
//  3.不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存
</script>
</body>
</html>