// 某些情况下，调用堆栈中函数调用的数量超出了调用堆栈的实际大小，浏览器会抛出一个错误终止运行。
// 对于下面的递归就会无限制的执行下去，直到超出调用堆栈的实际大小，这个是浏览器定义的
// function foo() {
//   foo();
// }
// foo();
//  RangeError:Maximum call stack size exceeded

// 1.栈数据结构
// 栈的结构就是后进先出（LIFO），如果读过前面两篇文章应该是相当熟悉了。文中使用乒乓球盒子的结构来解释。
// 处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。

// 2.堆数据结构
// 堆数据结构是一种树状结构。它的存取数据的方式与书架和书非常相似。我们只需要知道书的名字就可以直接取出书了，并不需要把上面的书取出来。
// JSON格式的数据中，我们存储的key-value可以是无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。

// 3.队列
// 队列是一种先进先出（FIFO）的数据结构，这是事件循环（Event Loop）的基础结构.


// 变量的存放
// 首先我们应该知道内存中有栈和堆，那么变量应该存放在哪里呢，堆？栈？
// 1、基本类型 --> 保存在栈内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。
//    基本类型一共有6种：Undefined、Null、Boolean、Number 、String和Symbol
// 2、引用类型 --> 保存在堆内存中，因为这种值的大小不固定，因此不能把它们保存到栈内存中，但内存地址大小的固定的，因此保存在堆内存中，
//    在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。
// 在计算机的数据结构中，栈比堆的运算速度快，Object是一个复杂的结构且可以扩展：数组可扩充，对象可添加属性，都可以增删改查。将他们放在堆中是为了不影响栈的效率。
//   而是通过引用的方式查找到堆中的实际对象再进行操作。所以查找引用类型值的时候先去栈查找再去堆查找。

var a = {n:1}
var b = a 
a.x = a = {n:2}
console.log(a.x)
console.log(b.x)