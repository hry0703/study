// JS是单线程的语言，执行顺序肯定是顺序执行，但是JS 引擎并不是一行一行地分析和执行程序，
//   而是一段一段地分析执行，会先进行编译阶段然后才是执行阶段。

// 执行上下文栈
//  因为JS引擎创建了很多的执行上下文，所以JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。
//  当 JavaScript 初始化的时候会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以程序结束之前， 执行栈最底部永远有个 globalContext。

// 函数上下文
//  在函数上下文中，用活动对象(activation object, AO)来表示变量对象。

// 活动对象和变量对象的区别在于
//  1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。
//  2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问。
//   调用函数时，会为其创建一个Arguments对象，并自动初始化局部变量arguments，指代该Arguments对象。所有作为参数传入的值都会成为Arguments对象的数组元素。

// 执行过程
//  执行上下文的代码会分成两个阶段进行处理
//   1、进入执行上下文
//   2、代码执行


// 进入执行上下文
//   很明显，这个时候还没有执行代码
//   此时的变量对象会包括（如下顺序初始化）：
//   1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。
//   2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。
//   3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。
// 上代码就直观了

function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;
}

foo(1);
//对于上面的代码，这个时候的AO是

AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
//形参arguments这时候已经有赋值了，但是变量还是undefined，只是初始化的值

// 代码执行
//  这个阶段会顺序执行代码，修改变量对象的值，执行完成后AO如下

AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}

//总结如下：
//  1、全局上下文的变量对象初始化是全局对象
//  2、函数上下文的变量对象初始化只包括 Arguments 对象
//  3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值
//  4、在代码执行阶段，会再次修改变量对象的属性值